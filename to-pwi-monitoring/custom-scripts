Step 1 — Move the file to a readable location

mkdir -p /etc/postgres_exporter

vi /etc/postgres_exporter/health_queries.yml

pg_health_wraparound_percent:
  query: |
    WITH max_age AS (
      SELECT 2000000000 AS max_old_xid,
             setting::int AS autovacuum_freeze_max_age
      FROM pg_settings WHERE name = 'autovacuum_freeze_max_age'
    ),
    per_db AS (
      SELECT datname,
             age(datfrozenxid) AS xid_age,
             m.max_old_xid,
             m.autovacuum_freeze_max_age
      FROM pg_database d
      CROSS JOIN max_age m
      WHERE datallowconn
    )
    SELECT max(xid_age) AS xid_age,
           max(100.0 * xid_age / max_old_xid) AS pct_wraparound,
           max(100.0 * xid_age / autovacuum_freeze_max_age) AS pct_emergency_vac
    FROM per_db;
  metrics:
    - xid_age:
        usage: "GAUGE"
        description: "Oldest xid age"
    - pct_wraparound:
        usage: "GAUGE"
        description: "Percent towards wraparound"
    - pct_emergency_vac:
        usage: "GAUGE"
        description: "Percent toward emergency autovac"


pg_health_freeze_lag:
  query: |
    SELECT setting::int AS autovacuum_freeze_max_age,
           age(datfrozenxid) AS oldest_xid,
           (setting::int - age(datfrozenxid)) AS remaining
    FROM pg_settings s
    JOIN pg_database d ON TRUE
    WHERE s.name = 'autovacuum_freeze_max_age'
    ORDER BY age(datfrozenxid) DESC LIMIT 1;
  metrics:
    - autovacuum_freeze_max_age:
        usage: "GAUGE"
    - oldest_xid:
        usage: "GAUGE"
    - remaining:
        usage: "GAUGE"


pg_health_bloat:
  query: |
    SELECT relname AS table,
           round(100 * (pg_total_relation_size(relid) - pg_relation_size(relid)) 
                 / pg_total_relation_size(relid), 2) AS bloat_pct
    FROM pg_catalog.pg_statio_user_tables
    ORDER BY bloat_pct DESC
    LIMIT 10;
  metrics:
    - table:
        usage: "LABEL"
    - bloat_pct:
        usage: "GAUGE"


pg_health_lock_waits:
  query: |
    SELECT wait_event_type, wait_event, count(*) AS total_waiting
    FROM pg_stat_activity
    WHERE wait_event IS NOT NULL
    GROUP BY wait_event_type, wait_event;
  metrics:
    - wait_event_type:
        usage: "LABEL"
    - wait_event:
        usage: "LABEL"
    - total_waiting:
        usage: "GAUGE"


pg_health_replication_lag:
  query: |
    SELECT application_name AS replica,
           EXTRACT(EPOCH FROM now() - pg_last_xact_replay_timestamp()) AS lag_seconds
    FROM pg_stat_replication;
  metrics:
    - replica:
        usage: "LABEL"
    - lag_seconds:
        usage: "GAUGE"


chmod 644 /etc/postgres_exporter/health_queries.yml

Step 2 — Update service file
vi /etc/systemd/system/postgres_exporter.service
[Unit]
Description=Postgres Exporter
After=network.target

[Service]
User=postgres
Group=postgres
Environment="DATA_SOURCE_NAME=postgresql://postgres@localhost:5432/postgres?sslmode=disable"

ExecStart=/usr/local/bin/postgres_exporter \
  --web.listen-address=":9187" \
  --extend.query-path="/etc/postgres_exporter/health_queries.yml"

Restart=always

[Install]
WantedBy=multi-user.target

reload
--------
systemctl daemon-reload
systemctl restart postgres_exporter

Verify

curl -s localhost:9187/metrics | grep pg_health

Update dashboard
